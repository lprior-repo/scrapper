version: '3'

tasks:
  # Essential Commands
  setup:
    desc: Complete setup for initial clone (infrastructure + dependencies + build)
    cmds:
      - echo "ðŸš€ Setting up complete development environment..."
      - echo "ðŸ³ Starting infrastructure..."
      - docker compose -f docker-compose.yml -f docker-compose.dev.yml up -d neo4j
      - task: wait-for-neo4j
      - echo "ðŸ“¦ Installing all dependencies..."
      - bun install
      - cd packages/webapp && bun install
      - bunx playwright install
      - echo "ðŸ”¨ Building application..."
      - go build -o bin/overseer .
      - bun run build
      - echo "âœ… Complete setup finished - ready for development!"

  test:
    desc: Run complete test suite with infrastructure at maximum speed
    cmds:
      - echo "ðŸš€ Running complete test suite at maximum speed..."
      - task: ensure-neo4j-running
      - task: setup-dependencies
      - echo "ðŸ“¦ Running Go unit tests in parallel..."
      - go test ./... -parallel 4 -timeout=30s -skip TestComprehensiveMutationTesting
      - echo "ðŸŽ¯ Running Go acceptance tests..."
      - go test ./... -run Acceptance -timeout=60s -parallel 2
      - echo "ðŸŒ Starting API server for testing..."
      - task: start-api-for-testing
      - echo "ðŸ” Running all API tests in parallel..."
      - task: test-api-all-parallel
      - echo "ðŸŽ­ Running Playwright E2E/Integration tests..."
      - task: test:e2e
      - task: stop-api-for-testing
      - task: cleanup-test-database
      - echo "âœ… All tests completed successfully!"

  dev:
    desc: Start comprehensive observability stack with full development environment
    cmds:
      - echo "ðŸš€ Starting comprehensive observability stack..."
      - task: ensure-observability-ready
      - task: setup-dependencies
      - echo "ðŸ“Š Starting observability services..."
      - 'echo "  ðŸ” Jaeger UI: http://localhost:16686"'
      - 'echo "  ðŸ“ˆ Metrics: http://localhost:2121/metrics"'
      - 'echo "  ðŸ“Š Neo4j: http://localhost:7474"'
      - 'echo "  ðŸ”§ API: http://localhost:8081"'
      - 'echo "  ðŸŒ Frontend: http://localhost:3000"'
      - echo ""
      - echo "ðŸš€ All services starting with comprehensive logging and tracing..."
      - echo "ðŸ“‹ Available observability features:"
      - echo "   â€¢ Real-time distributed tracing"
      - echo "   â€¢ Structured logging with correlation IDs"
      - echo "   â€¢ Performance metrics and monitoring"
      - echo "   â€¢ Error tracking and analysis"
      - echo "   â€¢ API rate limit monitoring"
      - echo "   â€¢ Database query performance tracking"
      - echo ""
      - echo "ðŸ“ Creating log directories..."
      - mkdir -p logs
      - echo "ðŸ”§ Starting API server with observability..."
      - |
        go run . api > logs/api.log 2>&1 &
        echo $! > logs/api.pid
        echo "API server started (PID: $(cat logs/api.pid))"
      - echo "ðŸŒ Starting frontend development server..."
      - |
        cd packages/webapp && bun --hot --port 3000 index.html > ../../logs/frontend.log 2>&1 &
        echo $! > ../../logs/frontend.pid
        echo "Frontend server started (PID: $(cat logs/frontend.pid))"
      - echo "ðŸ“‹ Aggregating logs..."
      - |
        touch logs/aggregated.log
        tail -f logs/api.log logs/frontend.log > logs/aggregated.log 2>&1 &
        echo $! > logs/log-aggregator.pid
      - echo ""
      - echo "âœ… All services running! Press Ctrl+C to stop gracefully."
      - echo "ðŸ“‹ Use 'task dev:logs' to view real-time logs"
      - echo "ðŸ“ˆ Use 'task dev:metrics' to check service status"
      - |
        trap 'echo "\nðŸ›‘ Stopping all services..."; 
        kill $(cat logs/api.pid 2>/dev/null) 2>/dev/null || true; 
        kill $(cat logs/frontend.pid 2>/dev/null) 2>/dev/null || true; 
        kill $(cat logs/log-aggregator.pid 2>/dev/null) 2>/dev/null || true; 
        rm -f logs/*.pid; 
        echo "âœ… All services stopped gracefully."; exit 0' INT TERM
        
        echo "Waiting for services to be ready..."
        timeout=30
        count=0
        until curl -s http://localhost:8081/api/health >/dev/null 2>&1 && curl -s http://localhost:3000 >/dev/null 2>&1; do
          if [ $count -ge $timeout ]; then
            echo "âš ï¸  Services didn't start within ${timeout} seconds"
            echo "Check logs: task dev:logs"
            break
          fi
          sleep 1
          count=$((count + 1))
        done
        
        if [ $count -lt $timeout ]; then
          echo "âœ… All services are ready and healthy!"
        fi
        
        # Keep the task running
        wait

  dev:webapp:
    desc: Start only the webapp development server
    cmds:
      - echo "ðŸŒ Starting webapp development server..."
      - mkdir -p logs
      - cd packages/webapp && bun --hot --port 3000 index.html

  dev:api:
    desc: Start only the API server
    cmds:
      - echo "ðŸ”§ Starting API server..."
      - task: ensure-neo4j-running
      - go run . api

  build:
    desc: Build all components
    cmds:
      - echo "ðŸ”¨ Building all components..."
      - go build -o bin/overseer .
      - bun run build
      - echo "âœ… Build completed!"

  build:webapp:
    desc: Build only the webapp
    cmds:
      - echo "ðŸ”¨ Building webapp..."
      - bun run build
      - echo "âœ… Webapp build completed!"

  clean:
    desc: Comprehensive cleanup of build artifacts, caches, and dependencies
    cmds:
      - echo "ðŸ§¹ Performing comprehensive cleanup..."
      - echo "ðŸ›‘ Stopping all services..."
      - go run . cleanup 2>/dev/null || true
      - docker compose down --volumes --remove-orphans 2>/dev/null || true
      - task: stop-api-for-testing
      - echo "ðŸ—‘ï¸  Cleaning build artifacts..."
      - rm -rf bin/
      - rm -rf packages/webapp/build/
      - rm -rf packages/webapp/dist/
      - rm -rf packages/shared/dist/
      - echo "ðŸ§½ Cleaning test artifacts..."
      - rm -f coverage.out coverage.html gosec-report.json
      - rm -f api_test.log api_test.pid
      - rm -rf test-results/
      - rm -rf playwright-report/
      - rm -rf tests/reports/
      - echo "ðŸ’¾ Cleaning caches and dependencies..."
      - rm -rf node_modules/
      - rm -rf packages/webapp/node_modules/
      - rm -rf packages/shared/node_modules/
      - rm -rf .bun/
      - rm -rf packages/webapp/.bun/
      - echo "ðŸ“‹ Cleaning logs..."
      - rm -rf logs/
      - mkdir -p logs
      - echo "âœ… Comprehensive cleanup completed!"

  lint:
    desc: Run linting across entire codebase (TypeScript and Go)
    cmds:
      - echo "ðŸ” Running TypeScript/JavaScript linting..."
      - bunx eslint packages/webapp/src packages/shared/src --ext .ts,.tsx,.js,.jsx
      - echo "ðŸ” Running Go linting..."
      - golangci-lint run ./... || echo "âš ï¸  golangci-lint not available, skipping Go linting"
      - echo "âœ… Linting completed!"

  lint:fix:
    desc: Run linting with auto-fix across entire codebase
    cmds:
      - echo "ðŸ”§ Running TypeScript/JavaScript linting with auto-fix..."
      - bunx eslint packages/webapp/src packages/shared/src --ext .ts,.tsx,.js,.jsx --fix
      - echo "ðŸ”§ Running Go formatting..."
      - go fmt ./...
      - echo "ðŸ”§ Running Go imports organization..."
      - goimports -w . || echo "âš ï¸  goimports not available, skipping Go imports"
      - echo "âœ… Linting with auto-fix completed!"

  type-check:
    desc: Run TypeScript type checking
    cmds:
      - echo "ðŸ” Running TypeScript type checking..."
      - bunx tsc --noEmit
      - echo "âœ… Type checking completed!"

  format:
    desc: Format all code (TypeScript, Go, JSON, YAML, etc.)
    cmds:
      - echo "ðŸŽ¨ Formatting all code..."
      - echo "ðŸ“ Formatting TypeScript/JavaScript files..."
      - bunx prettier --write "packages/**/*.{ts,tsx,js,jsx,json,md,css,html}"
      - bunx prettier --write "*.{json,md,yml,yaml}"
      - bunx prettier --write "tests/**/*.{ts,js,json}"
      - echo "ðŸ¹ Formatting Go files..."
      - go fmt ./...
      - goimports -w . || echo "âš ï¸  goimports not available, skipping Go imports formatting"
      - echo "ðŸ“‹ Formatting configuration files..."
      - bunx prettier --write "*.config.{ts,js}" || true
      - bunx prettier --write "**/*.config.{ts,js}" || true
      - echo "âœ… All code formatting completed!"

  test:e2e:
    desc: Run Playwright E2E tests
    cmds:
      - echo "ðŸŽ­ Running Playwright E2E tests..."
      - bunx playwright test --config=playwright.config.ts
      - echo "âœ… E2E tests completed!"

  test:e2e:ui:
    desc: Run Playwright E2E tests with UI
    cmds:
      - echo "ðŸŽ­ Running Playwright E2E tests with UI..."
      - bunx playwright test --config=playwright.config.ts --ui

  test:e2e:debug:
    desc: Debug Playwright E2E tests
    cmds:
      - echo "ðŸ› Running Playwright E2E tests in debug mode..."
      - bunx playwright test --config=playwright.config.ts --debug

  test:visual:
    desc: Run visual regression tests
    cmds:
      - echo "ðŸ“¸ Running visual regression tests..."
      - bunx playwright test --config=playwright.config.ts --grep="Visual Regression"
      - echo "âœ… Visual regression tests completed!"

  test:integration:
    desc: Run integration tests
    cmds:
      - echo "ðŸ”— Running integration tests..."
      - bunx playwright test --config=playwright.config.ts --grep="Integration"
      - echo "âœ… Integration tests completed!"

  test:component:
    desc: Run component-specific tests
    cmds:
      - echo "ðŸ§© Running component tests..."
      - bunx playwright test --config=playwright.config.ts --grep="Component"
      - echo "âœ… Component tests completed!"

  test:unit:
    desc: Run unit tests (using bun test runner)
    cmds:
      - echo "ðŸ§ª Running unit tests..."
      - cd packages/webapp && bun test
      - echo "âœ… Unit tests completed!"

  api-start:
    desc: Start API server and infrastructure for testing without running hurl tests
    cmds:
      - echo "ðŸš€ Starting API server and infrastructure for testing..."
      - task: ensure-neo4j-running
      - task: setup-dependencies
      - task: cleanup-test-database
      - task: start-api-for-testing
      - echo "âœ… API server and infrastructure ready for testing!"

  # Observability Commands
  dev:observability:
    desc: Start only observability services (Jaeger, metrics)
    cmds:
      - echo "ðŸ” Starting observability services..."
      - docker compose -f docker-compose.yml -f docker-compose.dev.yml up -d jaeger
      - task: wait-for-jaeger
      - echo "âœ… Observability services ready!"
      - 'echo "  ðŸ” Jaeger UI: http://localhost:16686"'
      - 'echo "  ðŸ“Š Traces: http://localhost:16686/search"'

  dev:logs:
    desc: View aggregated development logs in real-time
    cmds:
      - echo "ðŸ“‹ Viewing real-time aggregated logs..."
      - 'echo "ðŸ“ Log files: logs/aggregated.log, logs/api.log, logs/frontend.log"'
      - tail -f logs/aggregated.log || echo "âš ï¸  No log files found. Start development environment with 'task dev' first."

  dev:metrics:
    desc: Display current system metrics and performance data
    cmds:
      - echo "ðŸ“ˆ Current system metrics"
      - echo "API Health - $(curl -s http://localhost:8081/api/health | jq -r '.status // \"unavailable\"' || echo \"unavailable\")"
      - echo "Jaeger Status - $(curl -s http://localhost:16686 >/dev/null 2>&1 && echo \"running\" || echo \"unavailable\")"
      - echo "Neo4j Status - $(docker compose exec neo4j cypher-shell -u neo4j -p password \"RETURN 1\" >/dev/null 2>&1 && echo \"running\" || echo \"unavailable\")"
      - echo "Frontend Status - $(curl -s http://localhost:3000 >/dev/null 2>&1 && echo \"running\" || echo \"unavailable\")"

  dev:trace:
    desc: Open Jaeger UI for distributed tracing analysis
    cmds:
      - echo "ðŸ” Opening Jaeger tracing dashboard..."
      - 'echo "ðŸ“Š Jaeger UI: http://localhost:16686"'
      - 'echo "ðŸ” Service traces: http://localhost:16686/search"'
      - 'echo "ðŸ“ˆ Service dependencies: http://localhost:16686/dependencies"'

  # Internal/Support Tasks
  ensure-observability-ready:
    desc: Ensure all observability services are running and ready
    cmds:
      - task: ensure-neo4j-running
      - echo "ðŸ” Ensuring Jaeger is running..."
      - |
        if ! curl -s http://localhost:16686 >/dev/null 2>&1; then
          echo "Starting Jaeger..."
          docker compose -f docker-compose.yml -f docker-compose.dev.yml up -d jaeger
          task wait-for-jaeger
        else
          echo "Jaeger already running"
        fi
      - echo "âœ… All observability services ready!"

  ensure-neo4j-running:
    desc: Ensure Neo4j is running (don't restart if already up)
    cmds:
      - |
        if ! docker compose exec neo4j cypher-shell -u neo4j -p password "RETURN 1" > /dev/null 2>&1; then
          echo "Starting Neo4j..."
          docker compose -f docker-compose.yml -f docker-compose.dev.yml up -d neo4j
          task wait-for-neo4j
        else
          echo "Neo4j already running"
        fi

  wait-for-neo4j:
    desc: Wait for Neo4j to be ready
    cmds:
      - |
        echo "Waiting for Neo4j to be ready..."
        timeout=60
        count=0
        until docker compose exec neo4j cypher-shell -u neo4j -p password "RETURN 1" > /dev/null 2>&1; do
          if [ $count -ge $timeout ]; then
            echo "Neo4j failed to start within ${timeout} seconds"
            exit 1
          fi
          echo "Neo4j is not ready yet. Waiting 2 seconds... (${count}/${timeout})"
          sleep 2
          count=$((count + 2))
        done
        echo "Neo4j is ready!"

  wait-for-jaeger:
    desc: Wait for Jaeger to be ready
    cmds:
      - |
        echo "Waiting for Jaeger to be ready..."
        timeout=30
        count=0
        until curl -s http://localhost:16686 >/dev/null 2>&1; do
          if [ $count -ge $timeout ]; then
            echo "Jaeger failed to start within ${timeout} seconds"
            exit 1
          fi
          echo "Jaeger is not ready yet. Waiting 2 seconds... (${count}/${timeout})"
          sleep 2
          count=$((count + 2))
        done
        echo "Jaeger is ready!"

  setup-dependencies:
    desc: Install dependencies only when needed
    cmds:
      - bun install
      - bunx playwright install
    sources:
      - package.json
    generates:
      - node_modules/.bun-tag
    method: checksum

  start-api-for-testing:
    desc: Start API server for testing
    cmds:
      - |
        # Clean up any existing processes on ports
        lsof -ti:8081 | xargs -r kill -9 2>/dev/null || true
        lsof -ti:9094 | xargs -r kill -9 2>/dev/null || true
        sleep 0.5
        # Start API server in background with faster startup
        go run . api > api_test.log 2>&1 &
        echo $! > api_test.pid

        # Wait for server to be ready (reduced timeout)
        echo "â³ Waiting for API server to be ready..."
        timeout=15
        count=0
        until curl -s http://localhost:8081/api/health > /dev/null 2>&1; do
          if [ $count -ge $timeout ]; then
            echo "âŒ API server failed to start within ${timeout} seconds"
            if [ -f api_test.pid ]; then
              kill $(cat api_test.pid) 2>/dev/null || true
              rm -f api_test.pid
            fi
            exit 1
          fi
          sleep 0.5
          count=$((count + 1))
        done
        echo "âœ… API server is ready!"

  stop-api-for-testing:
    desc: Stop API server after testing
    cmds:
      - |
        if [ -f api_test.pid ]; then
          kill $(cat api_test.pid) 2>/dev/null || true
          rm -f api_test.pid
        fi
        pkill -f "go run . api" 2>/dev/null || true
        lsof -ti:8081 | xargs -r kill -9 2>/dev/null || true
        lsof -ti:9094 | xargs -r kill -9 2>/dev/null || true
        echo "âœ… API server stopped and ports cleaned"

  cleanup-test-database:
    desc: Clean up test database after test runs
    cmds:
      - |
        echo "ðŸ§¹ Cleaning up test database..."
        docker compose exec neo4j cypher-shell -u neo4j -p password "MATCH (n) DETACH DELETE n" || true
        echo "âœ… Test database cleaned"

  test-api-health:
    desc: Run health check API tests
    cmds:
      - hurl --test --variables-file tests/config/global.hurl tests/functional/health.hurl

  test-api-functional:
    desc: Run functional API tests
    internal: true
    cmds:
      - hurl --test --variables-file tests/config/global.hurl tests/functional/scan.hurl
      - hurl --test --variables-file tests/config/global.hurl tests/functional/graph.hurl
      - hurl --test --variables-file tests/config/global.hurl tests/functional/stats.hurl

  test-api-edge-cases:
    desc: Run edge case API tests (simplified)
    internal: true
    cmds:
      - hurl --test --variables-file tests/config/global.hurl tests/edge-cases/boundary-value-tests.hurl
      - hurl --test --variables-file tests/config/global.hurl tests/edge-cases/error-scenario-tests.hurl

  test-api-all-parallel:
    desc: Run all API tests in parallel for speed
    internal: true
    cmds:
      - |
        # Run API tests in parallel using background processes
        hurl --test --variables-file tests/config/global.hurl tests/functional/health.hurl &
        hurl --test --variables-file tests/config/global.hurl tests/functional/scan.hurl &
        hurl --test --variables-file tests/config/global.hurl tests/functional/graph.hurl &
        hurl --test --variables-file tests/config/global.hurl tests/functional/stats.hurl &
        hurl --test --variables-file tests/config/global.hurl tests/edge-cases/boundary-value-tests.hurl &
        hurl --test --variables-file tests/config/global.hurl tests/edge-cases/error-scenario-tests.hurl &
        # Wait for all background jobs to complete
        wait
        echo "âœ… All API tests completed in parallel"

  playwright:
    desc: Run Playwright E2E tests with full setup and teardown
    cmds:
      - echo "ðŸŽ­ Running Playwright E2E tests..."
      - task: test:e2e
      - task: stop-api-for-testing
      - task: cleanup-test-database
      - echo "âœ… Playwright tests completed!"